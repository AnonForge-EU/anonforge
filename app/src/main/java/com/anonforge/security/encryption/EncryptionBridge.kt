package com.anonforge.security.encryption

import android.util.Base64
import javax.crypto.Cipher
import javax.crypto.spec.GCMParameterSpec
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Encrypts and decrypts sensitive identity fields using AES-256-GCM.
 *
 * Security notes:
 * - Uses Android Keystore for key storage (hardware-backed when available)
 * - IV is generated by the system during encryption (required for Keystore keys)
 * - IV is prepended to ciphertext for storage/retrieval
 */
@Singleton
class EncryptionBridge @Inject constructor(
    private val keyManager: KeyManager
) {
    companion object {
        private const val ALGORITHM = "AES/GCM/NoPadding"
        private const val GCM_IV_LENGTH = 12
        private const val GCM_TAG_LENGTH = 128
    }

    /**
     * Encrypts plaintext using AES-256-GCM with Android Keystore key.
     *
     * Important: The IV is generated by the Android Keystore (required when
     * setRandomizedEncryptionRequired(true) is set on the key).
     *
     * @param plaintext The string to encrypt
     * @return Base64-encoded string containing IV + ciphertext
     */
    fun encrypt(plaintext: String): String {
        val key = keyManager.getFieldEncryptionKey()

        val cipher = Cipher.getInstance(ALGORITHM)

        // IMPORTANT: Don't provide IV for Android Keystore keys with randomizedEncryption
        // The system generates the IV automatically
        cipher.init(Cipher.ENCRYPT_MODE, key)

        // Retrieve the system-generated IV
        val iv = cipher.iv

        val plaintextBytes = plaintext.toByteArray(Charsets.UTF_8)
        val ciphertext = cipher.doFinal(plaintextBytes)

        // Combine IV + ciphertext for storage
        val combined = ByteArray(iv.size + ciphertext.size)
        System.arraycopy(iv, 0, combined, 0, iv.size)
        System.arraycopy(ciphertext, 0, combined, iv.size, ciphertext.size)

        // Securely wipe plaintext from memory
        plaintextBytes.fill(0)

        return Base64.encodeToString(combined, Base64.NO_WRAP)
    }

    /**
     * Decrypts data that was encrypted with [encrypt].
     *
     * @param encryptedData Base64-encoded string containing IV + ciphertext
     * @return The original plaintext string
     * @throws IllegalArgumentException if data is too short or corrupted
     */
    fun decrypt(encryptedData: String): String {
        val key = keyManager.getFieldEncryptionKey()
        val combined = Base64.decode(encryptedData, Base64.NO_WRAP)

        if (combined.size < GCM_IV_LENGTH) {
            throw IllegalArgumentException("Invalid encrypted data: too short")
        }

        // Extract IV and ciphertext
        val iv = combined.copyOfRange(0, GCM_IV_LENGTH)
        val ciphertext = combined.copyOfRange(GCM_IV_LENGTH, combined.size)

        val cipher = Cipher.getInstance(ALGORITHM)

        // For decryption, we MUST provide the IV that was used during encryption
        val spec = GCMParameterSpec(GCM_TAG_LENGTH, iv)
        cipher.init(Cipher.DECRYPT_MODE, key, spec)

        val plaintextBytes = cipher.doFinal(ciphertext)
        val result = String(plaintextBytes, Charsets.UTF_8)

        // Securely wipe decrypted bytes from memory
        plaintextBytes.fill(0)

        return result
    }
}